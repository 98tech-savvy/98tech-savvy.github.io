---
title:  "[CS] 메모리와 디스크의 핵심, 순차 논리"
excerpt: "컴퓨터는 비트를 어떻게 기억할까?"

//현재 카테고리: Computer, Blog, Python, License, Java, Javascript, VSCode, Git
categories:
  - Computer
tags:
  - [Computer, 컴퓨터과학, CS, 순차 논리, 메모리와 디스크 핵심]

toc: true
toc_sticky: true

date: 2023-04-16
last_modified_at: 2023-04-16
---

# 순차 논리<sup>sequential logic</sup>
**순차 논리**라는 말은 '**순**서대로 **차**례대로 **논리**!' 라고 생각하면 된다.
예를 들어 1부터 100까지 정수의 합계를 계산한다고 할 때, 현재 처리 중인 수가 어떤 수인지 알 수 없다면 1부터 100까지 정수의 합계를 계산할 수 없을 것이다. 사람은 직관적으로 시간을 알 수 있지만, 디지털 회로에서는 시간을 자연스럽게 다룰 수 없기 때문에 입력의 현재 상태와 과거 상태를 고려해 시간을 만들어 내고 과거를 기억하기 위한 회로를 만들어야하는 것이다.

# 시간을 표현하는 방법
하루는 1일이고, 1일은 24시간이고, 24시간은 1440분, 1440분은 86400초이다.
지구가 한 바퀴를 다 돌면(자전하면) '하루'라고 부르기로 했고, 1초는 지구 자전의 1/86400이다. 우리들은 지구의 주기같은 외부 이벤트로 시간을 표현할 수 있고, 괘종시계의 진자(똑딱이는 부분)가 오가는 시간을 주기로 활용해 시간을 측정할 수 있다.

## 발진자
![image](https://user-images.githubusercontent.com/128434645/232190417-adb24326-b5c1-4d0c-b1fa-dea779d2785e.png)
*[Wikipedia, Negative-feedback amplifier](https://en.wikipedia.org/wiki/Negative-feedback_amplifier)*

위 그림은  인버터의 출력과 입력을 연결 시킨 것이다. 인버터의 출력은 다시 입력으로, 입력은 다시 출력으로 반영되는데 이것을 **피드백<sup>feedback</sup>**이라고 하고, 이로 인해 출력은 **0과 1 사이를 진동한다.**

크리스털<sup>crystal</sup>을 사용하면 좀 더 안정적인 발진자를 만들 수 있는데, 크리스털을 전선에 연결하고 크리스털을 압축시키면 크리스털은 전기를 만들어낸다. 그리고 전기를 가하면 크리스털이 구부러지는데, 이러한 현상을 **피에조 전기<sup>piezoelectric</sup>**라고 부른다. 이러한 크리스털 발진자에 전자적인 단극쌍투 스위치를 사용해 전기를 가하고, 다시 전기를 얻어낸다. 입력한 전기로부터 크리스털이 전기를 만들어내는 시간은 예측이 가능하고 매우 정확해 적은 비용으로 효율적인 발진자를 만들 수 있다.

## 클록<sup>clock</sup>
발진자는 컴퓨터에 클록<sup>clock</sup>(시간을 셀 수 있게 해주는 신호)을 제공한다. 이 클록은 음악에서 드럼으로 템포를 조절하는 것과 같은 역할을 하는데, 회로의 페이스를 결정한다. 회로의 최대 클록 속도나 가장 빠른 템포를 회로의 전파 지연 시간에 의해 결정한다.

## 래치<sup>latch</sup>
![image](https://user-images.githubusercontent.com/128434645/232191330-9d720409-0a5e-468d-aa7c-9502b78f82c7.png)
*OR 게이트 래치*

이 회로는 위의 인버터와 달리 값을 반전시키지 않기 때문에 진동시키진 않는다.
out이 0으로 시작한다고 할 때, in에 1을 넣어주면 out이 1이 된다. 그리고 out(출력)이 OR의 다른쪽 입력(in의 다른쪽)에 들어가기 때문에 in에 다시 0을 넣어준다해도 이 out은 계속 1이 된다. 우리들은 **과거를 기억하는** 회로를 만들어냈다. 하지만 이 회로만으로는 0을 만들어 줄 수가 없기 때문에 AND게이트를 추가해줘서 피드백을 끊고 회로를 리셋할 방법을 만들어준다.
<br><br><br>
![image](https://user-images.githubusercontent.com/128434645/232192201-dcde027c-2a80-42b4-93e5-e5350a015b9d.png)
*AND-OR 게이트 래치*

인버터의 출력부분에 $reset$위의 바<sup>bar</sup>($\bar{reset}$) 기호는 하드웨어 기호에서 반전<sup>opposite</sup>을 뜻한다. $\bar{reset}$이 0이면 $reset$은 1이고, set을 1로 해준다면 

set = 1, reset = 0:
```
reset'0' > [INVERTER]reset'1' > [AND]'1'
             set'1' - [OR]'1' > 
```

AND와 OR 전부 1(High)의 값을 얻고, set을 0으로 바꿔준다고해도 AND와 OR은 계속해서 1을 출력한다.

하지만 reset이 1로 바뀐다면

set = 0, reset = 1:
```
1: reset'1' > [INVERTER]reset'0' > [AND]'0'
                set'0' - [OR]'1' >

2: reset'1' > [INVERTER]reset'0' > [AND]'0'
                set'0' - [OR]'0' >
```
의 순서로 AND와 OR이 0으로 바뀌기 때문에 최종적으로 out에 0을 출력하게 된다.
<br><br><br>

![image](https://user-images.githubusercontent.com/128434645/232194396-f02f7583-7020-4881-a931-510cfc5f7521.png)
*S-R 래치*

위 회로는 좀 더 똑똑하게 1비트 메모리를 만드는 방법이다. **S**et-**R**eset **래치**라고 하며, 액티브 로우(1을 0으로 표현, 인버터 생각하면 됨)입력이 들어오면 보수<sup>complementary</sup>출력을 제공한다. 이 보수 출력이 제공되면 출력의 한 쪽은 액티브 하이, 다른 쪽은 액티브 로우가 된다.

NOR게이트를 쓰면 입력이 액티브 하이인 S-R래치를 만들 수 있지만, 전력과 복잡도, 비용면에서 비효율적이다.

'AND-OR게이트 래치'에 비해 대칭적이라 set, reset 신호의 지연 시간이 비슷하다는 장점이 있다.

## 플립플롭<sup>flip-flop</sup>
위의 게이트들은 데이터 변경으로 인해 잘못된 결과가 생길 수 있다. 그래서 우리들은 그 잘못될 가능성을 최소화하기위해서 논리 수준이 특정 값에 머무는 동안 데이터를 잡지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 방식을 사용한다. 이런 방식을 **에지<sup>edge</sup>**라고 부른다. 에지에 의해 데이터 변화가 촉발되는 래치<sup>edge-triggered latch</sup>를 **플립플롭**이라고 한다.

![image](https://user-images.githubusercontent.com/128434645/232195475-210ddc86-1ecc-498c-9887-05b2df6f8a59.png)
*[Positive, Negative Edge Trigger](https://www.electrically4u.com/wp-content/uploads/2020/10/Edge-triggering.png?ezimgfmt=ng:webp/ngcb4)*

- Positive Edge triggering : D플립플롭이라고 부르며, 클럭이 상승할 때 플립플롭이 동작하는 방식이다. 0에서 1로 변할 때 상승 에지<sup>Rising Edge</sup>을 검출한다.

- Negative Edge triggering : 클럭이 하강할 때 플립플롭이 동작하는 방식으로, 하강 에지<sup>Falling Edge</sup>를 검출한다.

상태가 0에서 0으로, 1에서 1로 변하지 않는 경우에는 에지 트리거는 이벤트를 발생시키지 않는다.

![image](https://user-images.githubusercontent.com/128434645/232195783-be6e479a-4cad-40e9-b948-25d829cf5726.png)
[D-type flip-flop Schemetic](https://pfnicholls.com/Electronics/Dtype.html)

D 플립플롭의 스키매틱 기호다. S-R래치와 2개를 제외하곤 똑같고 S, R은 $\bar{S}$, $\bar{R}$이다(스키매틱 상에서는 보이지 않지만 S, R 박스 앞에 동그라미(O)표시가 있어서 값이 반전된 S바, R바다). 왼쪽의 D와 Ck는 데이터(Data)와 클록(Clock)을 뜻한다. Ck신호가 바뀔 때(0에서 1로) D의 값이 플립플롭에 저장되는 방식이다.

클록이 바뀔 때 데이터에서는 셋업 타임(설정 시간)과 홀드 타임(유지 시간)을 두는데, 셋업 타임에는 입력 신호가 안정적으로 유지돼야 하는지를 나타내고, 클록 에지가 발생한 이후에 얼마나 오랫동안 입력 신호가 안정적으로 유지하는지를 나타낸다.

![image](https://user-images.githubusercontent.com/128434645/232196382-0a168e57-048b-4dcb-96f5-1184b6d4fba8.png)
*[Setup time and Hold time](https://www.vlsi-expert.com/2011/04/static-timing-analysis-sta-basic-part3a.html)*

![image](https://user-images.githubusercontent.com/128434645/232196460-59c72df8-6f7b-42c8-8e8a-22c732d7870c.png)
*[Clock, Data, Q](https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29)*

그림에서 D의 값이 셋업 타임과 홀드 타임을 제외한 나머지 시간에는 D의 값이 변하더라도 출력에 영향이 없음을 알 수 있다. 그리고 전파 지연 시간이 지나야 D입력과 무관하게 안정적으로 유지됨도 알 수 있다. 보통 셋업 타임(**S**et**U**p time)을 t<sub>su</sub>, 유지 시간(Hold time)을 t<sub>h</sub>라고 한다.

## 카운터
위의 플립플롭을 응용한 회로 중에는 순서대로 수를 셀 수 있는 **카운터<sup>counter</sup>**가 있다.

![image](https://user-images.githubusercontent.com/128434645/232197191-b95696d3-da8c-4ae9-a686-1b7db04d99c9.png)
*[3 bit ripple counter](https://www.electricaltechnology.org/2018/05/digital-asynchronous-counter-ripple-counter-types.html)*

이 카운터는 **리플 카운터<sup>ripple counter</sup>**라고 하는데, 물에서 물결이 퍼지듯이 개수를 센 결과가 퍼지기 때문에 리플 카운터라고 부른다. Q<sub>0</sub>이 Q<sub>1</sub>를, Q<sub>1</sub>이 Q<sub>2</sub>를, 비트가 더 있으면 이러한 과정이 계속해서 반복된다(직렬로 연결된 회로의 단점?).

각 비트가 다른 비트의 상태 변화에 따라 약간의 시차를 두고 바뀌기 때문에 **비동기식 카운터<sup>asynchronous counter</sup>**라고 부른다. 언제 결과를 살펴봐야하는지 알기 어렵다는 단점이 있다(각 비트가 다른 비트의 상태 변화에 따라 약간의 텀을 두기 때문에).

그래서 우리들은 상태 변경을 동시화하기 위해서 **동기적 카운터<sup>synchronous counter</sup>**를 설계하기로 했다. 리플 카운터와 달리 동기적 카운터는 상태 변경이 동시에 (동기화되어) 일어나는데 이 말은 플립플롭에 같은 클록을 **병렬로 연결**했다는 사실을 암시한다.

![image](https://user-images.githubusercontent.com/128434645/232197981-dbe4ac89-ba77-46ac-bfe3-7d6e0fb763b0.png)
*[3-bit synchronous binary counter](https://www.iitg.ac.in/cseweb/vlab/Digital-System-Lab/up_counter.php?id=13)*

모든 플립플롭에 같은 클록이 병렬로 들어가기 때문에 이 카운터의 모든 플립플롭의 상태는 동시에 변한다. 위의 리플 카운터와 동기적 카운터 모두 전파 지연을 고려해서 출력이 어느 시점에 올바른지 알아야하지만, 연속적으로 퍼지는 리플 카운터의 단점은 없어졌다.

## 레지스터
이 'D 플립플롭'을 사용하면 그 유명한 **레지스터<sup>register</sup>**라는 회로를 쉽게 구할 수 있다(D 플립플롭을 사용하면 값을 쉽게 기억할 수 있기 때문에). 레지스터는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 집어넣은 것이다.

![image](https://user-images.githubusercontent.com/128434645/232199157-994b96c0-1d05-4cf8-9ef0-a9ff719b30d6.png)
*[4-bit Shift register with flip flop](https://stackoverflow.com/questions/30151197/4-bit-shift-register-with-flip-flop)*
